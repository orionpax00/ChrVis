<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - clipping planes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="js/three.js"></script>
		<script src="js/dat.gui.min.js"></script>


		<script src="js/TrackballControls.js"></script>


		<script src="js/WebGL.js"></script>




		<script src='js/LineSegmentsGeometry.js'></script>
		<script src='js/LineGeometry.js'></script>
		<script src='js/LineMaterial.js'></script>
		<script src='js/LineSegments2.js'></script>
		<script src='js/Line2.js'></script>


		<script>

			var camera, scene, renderer, startTime, object, stats, controls;
			var insetWidth;
			var insetHeight;
			var matLine;
			var r

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer();
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				window.addEventListener( 'resize', onWindowResize, false );
				document.body.appendChild( renderer.domElement );


				camera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 0.25, 1000 );




				controls = new THREE.TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;



				scene = new THREE.Scene();

				// ***** Clipping planes: *****

				var localPlane = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );
				var globalPlane = new THREE.Plane( new THREE.Vector3( - 1, 0, 0 ), 1 );

				// Position and Color Data

				var positions = [];
				var colors = [];

				// var points = hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );

				// console.log(points);
				var points = [];



				/// Reading local txt file
				function readTextFile(file)
				{
				    var rawFile = new XMLHttpRequest();
				    rawFile.open("GET", file, false);
				    rawFile.onreadystatechange = function ()
				    {
				        if(rawFile.readyState === 4)
				        {
				            if(rawFile.status === 200 || rawFile.status == 0)
				            {
				                var allText = rawFile.responseText;
				                // console.log(allText);

												var lines = allText.split("\n")
												// console.log(lines)
												lines = lines.filter(function(line){return line})
												// console.log(lines)

												for (var i=1; i < lines.length - 1; ++i){
													// console.log(lines[i].split(/\s/))

													if (lines[i].split(/\s/)[0] !== '#'){
														list_ = lines[i].split(/\s/);
														// if (parseInt(list_[0]) === 1){
																var chr_center = new THREE.Vector3(parseFloat(list_[2]), parseFloat(list_[3]), parseFloat(list_[4]))
																points.push(chr_center)
																// console.log(chr_center)
															// }
														}
													}
				            }
				        }
				    }
				    rawFile.send(null);
				}

				readTextFile("data/dummy_chromatin_str_fixed.txt");

				var spline = new THREE.CatmullRomCurve3( points );
				var divisions = Math.round( 12 * points.length );
				var color = new THREE.Color();

				for ( var i = 0, l = divisions; i < l; i ++ ) {
					var point = spline.getPoint( i / l );
					positions.push( point.x, point.y, point.z );
					color.setHSL( i / l, 1.0, 0.5 );
					colors.push( color.r, color.g, color.b );

				}


				// THREE.Line2 ( LineGeometry, LineMaterial )

				var geometry = new THREE.LineGeometry();
				var center = new THREE.Vector3();
				geometry.setPositions( positions );
				geometry.setColors( colors );
				centerx = -geometry.boundingBox.getCenter(center).x;
				centery = -geometry.boundingBox.getCenter(center).y;
				centerz = -geometry.boundingBox.getCenter(center).z;
				geometry.applyMatrix( new THREE.Matrix4().makeTranslation( centerx, centery, centerz ) );

				matLine = new THREE.LineMaterial( {
					color: 0xffffff,
					linewidth: 5, // in pixels
					vertexColors: THREE.VertexColors,
					dashed: false,
				} );
				matLine.clipping = true;



				r = geometry.boundingSphere.radius * 2;

				thick_line = new THREE.Line2( geometry, matLine );
				thick_line.computeLineDistances();
				thick_line.visible = true;
				scene.add(thick_line)

				var helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxBufferGeometry( r, r, r ) ) );
				helper.material.color.setHex( 0xffffff);
				helper.material.opacity = 0.25;
				helper.material.blending = THREE.AdditiveBlending;
				helper.material.transparent = true;
				scene.add( helper );

				console.log(matLine);


				var geo = new THREE.BufferGeometry();
				geo.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geo.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geo.computeBoundingBox();

		    middlex = -(geo.boundingBox.max.x + geo.boundingBox.min.x) / 2;
		    middley = -(geo.boundingBox.max.y + geo.boundingBox.min.y) / 2;
		    middlez = -(geo.boundingBox.max.z + geo.boundingBox.min.z) / 2;
				geo.applyMatrix( new THREE.Matrix4().makeTranslation( middlex, middlez, middlez ) );

				matLineBasic = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, clippingPlanes : [globalPlane] } );
				thin_line = new THREE.Line( geo, matLineBasic );
				thin_line.computeLineDistances();
				thin_line.visible = false;
				scene.add( thin_line );


				var helpers = new THREE.Group();
				helpers.add( new THREE.PlaneHelper( globalPlane, r, 0xf00f00 ) );
				helper.material.opacity = 0.25;
				helpers.visible = true;
				scene.add( helpers );

				object = new THREE.Mesh( geometry, matLine );
				object.castShadow = true;

				var globalPlanes = [ globalPlane ],
					Empty = Object.freeze( [] );
				renderer.clippingPlanes = Empty; // GUI sets it to globalPlanes
				renderer.localClippingEnabled = true;

				camera.position.z = r * 2 ;

				var gui = new dat.GUI(),

					folderGlobal = gui.addFolder( 'Clipping' ),
					propsGlobal = {

						get 'Enabled'() {
							return !matLine.clipping;
						},

						set 'Enabled'( v ) {
							matLine.clippingPlanes = [globalPlane] ;
						},

						get 'Plane'() {
							return globalPlane.constant;
						},

						set 'Plane'( v ) {
							globalPlane.constant = v;
						}

					};

					folderplane = gui.addFolder( 'Helper Plane' ),
					propsplane = {

						get 'Enabled'() {
							return helpers.visible !== true;
						},

						set 'Enabled'( v ) {
							console.log(v);
							helpers.visible = !v;
						},
					};

				folderGlobal.add( propsGlobal, 'Enabled' );
				folderGlobal.add( propsGlobal, 'Plane', - r/2, r/2 );
				folderplane.add( propsplane, 'Enabled' );

				// Start

				startTime = Date.now();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				controls.handleResize();

				insetWidth = window.innerHeight / 4; // square
				insetHeight = window.innerHeight / 4;

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				var currentTime = Date.now();
				var time = ( currentTime - startTime ) / 1000;

				requestAnimationFrame( animate );
				controls.update();

				renderer.setClearColor( 0x000000, 0 );
				renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );

				// renderer will set this eventually
				matLine.resolution.set( window.innerWidth, window.innerHeight ); // resolution of the viewport
				renderer.render( scene, camera );

				// inset scene

				renderer.setClearColor( 0x222222, 1 );

				renderer.clearDepth(); // important!

				renderer.setScissorTest( true );

				renderer.setScissor( 20, 20, insetWidth, insetHeight );

				renderer.setViewport( 20, 20, insetWidth, insetHeight );


				// renderer will set this eventually
				matLine.resolution.set( insetWidth, insetHeight ); // resolution of the inset viewport


				renderer.setScissorTest( false );
			}

		</script>

	</body>
</html>
