<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - clipping planes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
    <script src="js/theme.js"></script>
		<script src="js/three.js"></script>
		<script src="js/dat.gui.min.js"></script>


		<script src="js/TrackballControls.js"></script>


		<script src="js/WebGL.js"></script>




		<script src='js/LineSegmentsGeometry.js'></script>
		<script src='js/LineGeometry.js'></script>
		<script src='js/LineMaterial.js'></script>
		<script src='js/LineSegments2.js'></script>
		<script src='js/Line2.js'></script>


		<script>

			var camera, scene, renderer, startTime, object, stats, controls;
			var insetWidth;
			var insetHeight;

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer();
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				window.addEventListener( 'resize', onWindowResize, false );
				document.body.appendChild( renderer.domElement );


				camera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 0.25, 1000 );

				camera.position.z = 100;


				controls = new THREE.TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;



				scene = new THREE.Scene();

				// ***** Clipping planes: *****

				var localPlane = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );
				var globalPlane = new THREE.Plane( new THREE.Vector3( - 1, 0, 0 ), 1 );

				// Position and Color Data

				var positions = [];
				var colors = [];

				// var points = hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );

				// console.log(points);
				var points = [];
        var color_ = [];



				/// Reading local txt file
				function readTextFile(file)
				{
				    var rawFile = new XMLHttpRequest();
				    rawFile.open("GET", file, false);
				    rawFile.onreadystatechange = function ()
				    {
				        if(rawFile.readyState === 4)
				        {
				            if(rawFile.status === 200 || rawFile.status == 0)
				            {
				                var allText = rawFile.responseText;
				                // console.log(allText);

												var lines = allText.split("\n")
												// console.log(lines)
												lines = lines.filter(function(line){return line})
												// console.log(lines)

												for (var i=1; i < lines.length - 1; ++i){
													// console.log(lines[i].split(/\s/))

													if (lines[i].split(/\s/)[0] !== '#'){
														list_ = lines[i].split(/\s/);
														// if (parseInt(list_[0]) === 1){
																var chr_center = new THREE.Vector3(parseFloat(list_[2]), parseFloat(list_[3]), parseFloat(list_[4]))
																points.push(chr_center)
                                color_.push(colors[parseInt(list_[0])])
																// console.log(chr_center)
															// }
														}
													}
				            }
				        }
				    }
				    rawFile.send(null);
				}
				readTextFile("data/merge_3d_inter.txt");

				// THREE.Line2 ( LineGeometry, LineMaterial )




				var helpers = new THREE.Group();
				helpers.add( new THREE.PlaneHelper( globalPlane, 100, 0xff0ff0 ) );

				helpers.visible = true;
				scene.add( helpers );



				var globalPlanes = [ globalPlane ],
					Empty = Object.freeze( [] );
				renderer.clippingPlanes = Empty; // GUI sets it to globalPlanes
				renderer.localClippingEnabled = false;

				var gui = new dat.GUI(),

					folderGlobal = gui.addFolder( 'Clipping' ),
					propsGlobal = {

						get 'Enabled'() {
							return renderer.clippingPlanes !== Empty;
						},

						set 'Enabled'( v ) {
							renderer.clippingPlanes = v ? globalPlanes : Empty;
						},

						get 'Plane'() {
							return globalPlane.constant;
						},

						set 'Plane'( v ) {
							globalPlane.constant = v;
						}

					};

					folderplane = gui.addFolder( 'Helper Plane' ),
					propsplane = {

						get 'Enabled'() {
							return helpers.visible !== true;
						},

						set 'Enabled'( v ) {
							console.log(v);
							helpers.visible = !v;
						},
					};

				folderGlobal.add( propsGlobal, 'Enabled' );
				folderGlobal.add( propsGlobal, 'Plane', - 240, 300 );
				folderplane.add( propsplane, 'Enabled' );

				// Start

				startTime = Date.now();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				controls.handleResize();

				insetWidth = window.innerHeight / 4; // square
				insetHeight = window.innerHeight / 4;

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				var currentTime = Date.now();
				var time = ( currentTime - startTime ) / 1000;

				requestAnimationFrame( animate );
				controls.update();

				renderer.setClearColor( 0x000000, 0 );
				renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );

				// renderer will set this eventually
				renderer.render( scene, camera );

				// inset scene

				renderer.setClearColor( 0x222222, 1 );

				renderer.clearDepth(); // important!

				renderer.setScissorTest( true );

				renderer.setScissor( 20, 20, insetWidth, insetHeight );

				renderer.setViewport( 20, 20, insetWidth, insetHeight );




				renderer.setScissorTest( false );
			}

		</script>

	</body>
</html>
