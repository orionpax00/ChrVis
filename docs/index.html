<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>ChrVis</title>
		<link rel="stylesheet" href="./css/color-picker.css">
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
      #controls{
        position:absolute;
      }
			#tooltip_id{
				position: fixed;
				right: 100px
			}
			#tooltip_id span{
				color:#fff
			}
		</style>
		<script
	  src="https://code.jquery.com/jquery-3.4.1.js"
	  integrity="sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU="
	  crossorigin="anonymous"></script>
    <script src="js/three.min.js"></script>
    <script src="js/WebGL.js"></script>
    <script src="js/OrbitControls.js"></script>
		<script src="js/Raycaster.js"></script>
		<script src="js/color-picker.min.js"></script>
	</head>
	<body>
		<div id=tooltip_id>
			<div id="tooltip-div">
				<span>Name:</span>
				<span id="tooltip-name"></span>
			</div>
		</div>
    <div id="controls">
      <button type="button" name="Rotate" onclick="rotate()">
        Rotate on
      </button>
      <br>
      <button type="button" name="Rotate" onclick="rotateoff()">
        Rotate off
      </button>
			<br>
      <button type="button" name="Rotate" onclick="removelinetype()">
        remove line type
      </button>
			<br>
      <button type="button" name="Rotate" onclick="removeatomtype()">
        off atom one by one
      </button>

			<br>
      <button type="button" name="Rotate" onclick="removeatomtypeall()">
        off atom all
      </button>

			<br>
      <button type="button" name="Rotate" onclick="changelinetype()">
        change line type
      </button>
				<br>
			<button type="button" name="Rotate">
        change background color <input type="text">
      </button>

    </div>

		<script>

      if( WEBGL.isWebGLAvailable()) {

				//color picker instance
				var picker = new CP(document.querySelector('input[type="text"]'));

				var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
        var controls = new THREE.OrbitControls( camera );
        var renderer = new THREE.WebGLRenderer();


				var geometry = new THREE.Geometry()
				geometry.vertices = [];
				var data_loc = 'https://raw.githubusercontent.com/primus00/jsonhost/master/dummy_chromatin_str.txt';
				var_data_small = 'https://raw.githubusercontent.com/primus00/jsonhost/master/model.136.xyz';

				jQuery.get(data_loc, function(data) {
								var chrdata = data;
								// console.log(chrdata)
								var lines = chrdata.split("\n")
								// console.log(lines)
								lines = lines.filter(function(line){return line})
								// console.log(lines)

								for (var i=1; i < lines.length - 1; ++i){
									// console.log(lines[i].split(/\s/))

									if (lines[i].split(/\s/)[0] !== '#'){
										list_ = lines[i].split(/\s/);
										// console.log(list_[2]);
										if (parseInt(list_[0]) === 1){
												var chr_center = new THREE.Vector3(parseFloat(list_[2]), parseFloat(list_[3]), parseFloat(list_[4]))
												geometry.vertices.push(chr_center)
											}
										// console.log("dbhsdbhj")

										}
									}

        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );




        var sphereGeometry = new THREE.SphereGeometry(1,50,50);
        var sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000,opacity:1});
				var setsphereMaterial = new THREE.MeshPhongMaterial( { color: 0x00d9ff } );
				var material = new THREE.LineBasicMaterial( { color: 0x0000ff,
                                                      linewidth: 5,
                                                      linecap:'round',
                                                      linejoin:'round'} );
        var line = new THREE.Line( geometry, material );

				for (var j = 0; j <geometry.vertices.length -1; ++j){
					var allsphers = [ ];
					allsphers[j] = new THREE.Mesh(sphereGeometry,sphereMaterial);
	        allsphers[j].position.x = geometry.vertices[j].x;
					allsphers[j].position.y = geometry.vertices[j].y;
					allsphers[j].position.z = geometry.vertices[j].z;
					allsphers[j].name = "chr1"
					scene.add(allsphers[j]);
					allsphers[j].updateMatrix();
 				  allsphers[j].matrixAutoUpdate=false;

				}

        var gridXZ = new THREE.GridHelper(10, 1);
        var axes = new THREE.AxesHelper(2);
        // scene.add(axes);
        // scene.add(gridXZ);

        // scene.add(sphere);
        // scene.add(sphere2);
				line.name = "chr_line";
        scene.add(line);

				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('mousemove', onDocumentMouseMove, false);


        //controls.update() must be called after any manual changes to the camera's transform
        camera.position.set( 0, 20, 100 );
        controls.update();


  			var render = function () {
          requestAnimationFrame( render );
          // controls.autoRotate(true);
          controls.update();
          renderer.render( scene, camera );
  			};
				//uncoment thisline to for visulisation
				render()

				});

				function removelinetype(){
					var selectedObject = scene.getObjectByName("chr_line");
					scene.remove( selectedObject );
				};
				function removeatomtype(){
					var selectedObject = scene.getObjectByName("chr1");
					scene.remove( selectedObject )
				}
				function removeatomtypeall(){
					while(scene.getObjectByName("chr1", 'true')){
						var selectedObject = scene.getObjectByName("chr1");
						scene.remove( selectedObject )

					}
				}
				function changelinetype(){
					removelinetype();
				var numpoints =100000,
				spline = new THREE.CatmullRomCurve3(geometry.vertices)

				var material = new THREE.LineBasicMaterial({
				    color: 0xff00f0,
				});

				var geometry_ = new THREE.Geometry();
				var splinePoints = spline.getPoints(numpoints);

				for(var i = 0; i < splinePoints.length; i++){
				    geometry_.vertices.push(splinePoints[i]);
				}

				var line = new THREE.Line(geometry_, material);
				scene.add(line);

				};
				var intersected = [];
				function onDocumentMouseMove(event) {

				    event.preventDefault();

						mouseYOnMouseDown = - ( event.clientY / window.innerHeight ) * 2 + 1
				    mouseXOnMouseDown = ( event.clientX / window.innerWidth ) * 2 - 1;

				    var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
				    vector = vector.unproject(camera);

				    var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
				    var intersects = raycaster.intersectObjects(scene.children, true); // Circle element which you want to identify

						// console.log(intersects);
						var setsphereGeometry = new THREE.SphereGeometry(2,50,50);
						var sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000,opacity:1});
		        var setsphereMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00,opacity:1});

						var istooltipexist = document.getElementById('tooltip-name');

						if(intersects.length>0){
							// console.log(intersects[0].object.name);
							if (intersects[0].object.name === 'chr1'){
								if (intersected.length > 0) {
									intersected[0].object.material = sphereMaterial;
									// console.log(mouseYOnMouseDown, mouseXOnMouseDown)
								}
								istooltipexist.innerHTML = "chr1";
								intersects[0].object.material = setsphereMaterial;
								intersected[0] = intersects[0];
							}
						}
						else{
							istooltipexist.innerHTML = "";
						}

				}


				function onDocumentMouseDown(event) {

				    event.preventDefault();

				    mouseYOnMouseDown = - ( event.clientY / window.innerHeight ) * 2 + 1
				    mouseXOnMouseDown = ( event.clientX / window.innerWidth ) * 2 - 1;

				    var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
				    vector = vector.unproject(camera);

				    var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
				    var intersects = raycaster.intersectObjects(scene.children, true); // Circle element which you want to identify

				    // console.log(intersects)

				}

				function rotate() {
            controls.autoRotate = true;
            controls.autoRotateSpeed = 30;
            controls.update()
        }
				function rotateoff() {
            controls.autoRotate = false;
            controls.update()
        }

				function rotateoff() {
            controls.autoRotate = false;
            controls.update()
        }
				picker.set('rgb(0, 0, 0)');
				picker.on("change", function(color_) {
							scene.background = new THREE.Color("#"+ color_ );
					});
				// scene.background = new THREE.Color( 0x000000 );
      }


      else {
      	var warning = WEBGL.getWebGLErrorMessage();
      	document.getElementById( 'container' ).appendChild( warning );
      }
		</script>

		<!-- General function not related to threejs -->
		<script>
		</script>

	</body>
</html>
